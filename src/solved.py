import csv
import fnmatch
import random
import secrets
from collections import Counter
from itertools import combinations, combinations_with_replacement, permutations, product
from pathlib import Path

import util


def problem1():
    """Problem 1 Euler.

    If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below .
    """
    return sum([ea for ea in range(1000) if (ea % 3 == 0 or ea % 5 == 0)])


def problem2():
    """Problem 2 Euler.

    Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
    1,2,3,5,8,13,21,34,55,89...
    By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
    """
    li = util.generate_fibonacci(4000000)
    return sum([ea for ea in li if ea % 2 == 0])


def problem3(num=600851475143):
    """Problem 3 Euler.

    The prime factors of 13195 are 5, 7, 13 and 29.
    What is the largest prime factor of the number 600851475143?
    """
    return max(util.prime_factors(num))


def problem4():
    """Problem 4 Euler.

    A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 times 99.
    Find the largest palindrome made from the product of two 3-digit numbers.
    """
    return max(
        [
            ea_1 * ea_2
            for ea_1 in range(999, 100, -1)
            for ea_2 in range(999, 100, -1)
            if util.is_palindrome(ea_1 * ea_2)
        ],
    )


def problem5():
    """Euler Problem 5.

    2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
    What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
    """
    i = 2520  # Gave a starting point
    vals = list(range(1, 21))
    while True:
        i += 2520  # Gunna have to also be divisible by this
        if util.divisible_by_all(i, vals):
            return i


def problem6():
    """Euler Problem 6.

    The sum of the squares of the first ten natural numbers is,
    1^2 + 2^2 + ... + 10^2 = 385
    The square of the sum of the first ten natural numbers is,
    (1 + 2 + ... + 10)^2 = 55^2 = 3025
    Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 - 385 = 2640.
    Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
    """

    def sum_of_squares(li):
        val = 0
        for ea in li:
            val += ea * ea
        return val

    a = sum(range(1, 101)) ** 2
    b = sum_of_squares(range(1, 101))
    return a - b


def problem7(num=10001):
    """Euler Problem 7.

    By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
    What is the 10,001st prime number?
    """
    i = 2
    li = []

    while True:
        if util.is_prime(i):
            li.append(i)
            if len(li) == num:
                return li[-1]
        i += 1


def problem7_alt(num=10001):
    """Euler Problem 7.

    By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
    What is the 10,001st prime number?
    """

    def get_nth_prime(nth_prime):
        prime_list = [2]
        num = 3
        while len(prime_list) < nth_prime:
            # The only numbers you care about are primes, since a prime is not divisible by any other primes.
            if not util.divisible_by_any(num, prime_list):
                prime_list.append(num)
            num += 2
        return prime_list[-1]

    return get_nth_prime(num)


def problem8(
    num=7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450,
    consecutive=13,
):
    """Euler Problem 8.

    The four adjacent digits in the 1000-digit number that have the greatest product are 9 times 9 times 8 times 9 = 5832.
    73167176531330624919225119674426574742355349194934
    96983520312774506326239578318016984801869478851843
    85861560789112949495459501737958331952853208805511
    12540698747158523863050715693290963295227443043557
    66896648950445244523161731856403098711121722383113
    62229893423380308135336276614282806444486645238749
    30358907296290491560440772390713810515859307960866
    70172427121883998797908792274921901699720888093776
    65727333001053367881220235421809751254540594752243
    52584907711670556013604839586446706324415722155397
    53697817977846174064955149290862569321978468622482
    83972241375657056057490261407972968652414535100474
    82166370484403199890008895243450658541227588666881
    16427171479924442928230863465674813919123162824586
    17866458359124566529476545682848912883142607690042
    24219022671055626321111109370544217506941658960408
    07198403850962455444362981230987879927244284909188
    84580156166097919133875499200524063689912560717606
    05886116467109405077541002256983155200055935729725
    71636269561882670428252483600823257530420752963450
    Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?
    """
    li = [int(x) for x in str(num)]
    highest = 0
    for i in range(1, len(li) - consecutive):
        highest = max(util.multiply_list(li[i : i + consecutive]), highest)
    return highest


def problem9(desired_sum):
    """Euler Problem 9.

    A Pythagorean triplet is a set of three natural numbers, a<b<c, for which a^2 + b^2 = c^2
    For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2
    There exists exactly one Pythagorean triplet for which a + b + c = 1000.
    Find the product a*b*c
    """
    a, b, c = 1, 2, 3
    for a in range(1, desired_sum // 3):
        for b in range(a, desired_sum // 2):
            for c in range(max(b, desired_sum // 3), desired_sum - b - a + 1):
                if a**2 + b**2 == c**2 and a + b + c == desired_sum:
                    return a * b * c
    return None


def problem10():
    """Euler Problem 10.

    The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
    Find the sum of all the primes below two million.
    """

    def prime_list(n):
        prime = [True] * n
        for i in range(3, int(n**0.5) + 1, 2):
            if prime[i]:
                prime[i * i :: 2 * i] = [False] * ((n - i * i - 1) // (2 * i) + 1)
        return [2] + [i for i in range(3, n, 2) if prime[i]]

    return sum(prime_list(2000000))


def problem11():
    def get_rows(grid, adj):
        li = []
        for row_num in range(len(grid)):
            for col_num in range(len(grid[row_num]) - adj + 1):
                temp = [grid[row_num][col_num + offset] for offset in [0, 1, 2, 3]]
                li.append(temp)
        return li

    def get_cols(grid, adj):
        li = []
        for row_num in range(len(grid) - adj + 1):
            for col_num in range(len(grid[row_num])):
                temp = [grid[row_num + offset][col_num] for offset in [0, 1, 2, 3]]
                li.append(temp)
        return li

    def get_diags(grid, adj):
        li = []
        for row_num in range(len(grid) - adj + 1):
            for col_num in range(len(grid[row_num]) - adj + 1):
                temp = [grid[row_num + offset][col_num + offset] for offset in [0, 1, 2, 3]]
                li.append(temp)
            for col_num in range(adj - 1, len(grid[row_num])):
                temp = [grid[row_num + offset][col_num - offset] for offset in [0, 1, 2, 3]]
                li.append(temp)
        return li

    grid = util.import_2d_array_data("data/SumGrid.csv")
    adj = 4
    li = get_rows(grid, adj)
    li += get_cols(grid, adj)
    li += get_diags(grid, adj)

    max_value = 0
    for line in li:
        max_value = max(max_value, util.multiply_list(line))
    return max_value


def problem12(desired_divisors=500):
    """Euler Problem 12.

    The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
    1, 3, 6, 10, 15, 21, 28, 36, 45, 55,...
    Let us list the factors of the first seven triangle numbers:
    1 : 1
    3 : 1,3
    6 : 1,2,3,6
    10 : 1,2,5,10
    15 : 1,3,5,15
    21 : 1,3,7,21
    28 : 1,2,4,7,14,28
    We can see that 28 is the first triangle number to have over five divisors.
    What is the value of the first triangle number to have over five hundred divisors?
    """
    num = 28
    inc = 7
    while len(util.find_all_divisors(num)) < desired_divisors:
        inc += 1
        num += inc
    return num


def problem13(filename):
    """Euler Problem 13.

    Work out the first ten digits of the sum of the following one-hundred -digit numbers. [included as CSV file LargeSum.csv]
    """
    with Path(filename).open() as csvdatafile:
        li = list(csv.reader(csvdatafile))
    for ea in range(len(li)):
        li[ea] = int(li[ea][0])
    return str(sum(li))[0:10]


def problem14(highest_num):
    """Euler Problem 14.

    The following iterative sequence is defined for the set of positive integers:
    n => n/2 (n is even)
    n => 3n+1 (n is odd)

    Using the rule above and starting with 13, we generate the following sequence:
    13, 40, 20, 10, 5, 16, 8, 4, 2, 1.
    It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.
    Which starting number, under one million, produces the longest chain?
    Once the chain starts the terms are allowed to go above one million.
    """

    def eval_collatz(num):
        curriter = 0
        while num != 1:
            curriter += 1
            num = num / 2 if num % 2 == 0 else 3 * num + 1
        return curriter

    max_collatz = 0
    value = 0
    for ea in range(1, highest_num):
        c = eval_collatz(ea)
        if max_collatz < c:
            max_collatz = c
            value = ea
    return value


def problem15(n):
    """Euler Problem 15.

    Starting in the top left corner of a 2x2 grid, and only being able to move to the right and down, there are exactly 6 routes to the bottom right corner
    How many such routes are there through a 20x20 grid?
    """
    return util.binomial_coefficient(2 * n, n)


def problem16(base, exponent):
    """Euler Problem 16.

    2^15 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.
    What is the sum of the digits of the number 2^1000?
    """
    val = base**exponent
    return sum(util.convert_int_to_list(val))


def problem17():
    """Euler Problem 17.

    If the numbers 1 to 5 are written out in words: one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total
    If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?
    Do not count spaces or hyphens. For example, 342 (three hundred and forty-two) contains 23 letters and 115 (one hundred and fifteen) contains 20 letters. The use of "and" when writing out numbers is in compliance with British usage
    """

    def num_len(n):
        def below_100(n, lasts, tens):
            if n < len(lasts):
                return lasts[n]
            return tens[max(n // 10, 0)] + lasts[n % 10]

        lasts = [
            0,
            len("one"),
            len("two"),
            len("three"),
            len("four"),
            len("five"),
            len("six"),
            len("seven"),
            len("eight"),
            len("nine"),
            len("ten"),
            len("eleven"),
            len("twelve"),
            len("thirteen"),
            len("fourteen"),
            len("fifteen"),
            len("sixteen"),
            len("seventeen"),
            len("eighteen"),
            len("nineteen"),
        ]
        tens = [
            0,
            0,
            len("twenty"),
            len("thirty"),
            len("forty"),
            len("fifty"),
            len("sixty"),
            len("seventy"),
            len("eighty"),
            len("ninety"),
        ]
        tot = 0
        h = int(n // 100) % 10
        t = int(n // 1000)
        s = n % 100

        one_hundred, nineninenine = 100, 999

        if n < one_hundred:
            return below_100(n, lasts, tens)

        if n > nineninenine:
            tot += below_100(t, lasts, tens) + len("thousand")
        if h != 0:
            tot += lasts[h] + len("hundred")
        if s != 0:
            tot += len("and") + below_100(s, lasts, tens)
        return tot

    running_tot = 0
    for n in range(1, 1001):
        running_tot += num_len(n)
    return running_tot


def problem18(filename="data/TriangleSum.csv"):
    """Euler Problem 18.

    By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.
    Find the maximum total from top to bottom of the triangle below: [data/TriangleSum.csv]
    note: As there are only 16384 routes, it is possible to solve this problem by trying every route. However, Problem 67, is the same challenge with a triangle containing one-hundred rows; it cannot be solved by brute force, and requires a clever method! ;o)
    """
    grid = util.import_2d_array_data(filename)

    # Solution is based on rolling up from bottom.
    # Each row will be the sum of the maximum path downwards.
    # Each item touches 2 below it-> same col and 1 to the right.

    for row_num in range(len(grid) - 2, -1, -1):  # -2 because -1 would be last, need to start 1 higher
        for col_num in range(len(grid[row_num])):
            grid[row_num][col_num] += max(grid[row_num + 1][col_num], grid[row_num + 1][col_num + 1])
    return grid[0][0]


def problem19():
    """Euler Problem 19.

    You are given the following information, but you may prefer to do some research for yourself:
        1 Jan 1900 was a Monday.
        Thirty days has September,
        April, June and November.
        All the rest have thirty-one,
        Saving February alone,
        Which has twenty-eight, rain or shine.
        And on leap years, twenty-nine.
        A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400.
    How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?
    """

    def is_leap_year(year):
        return bool(year % 4 == 0 and (year % 100 != 0 or year % 400 == 0))

    month_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]  # how many days in each month
    a = 2  # 1901 starts on a Tuesday
    sun = 0  # Number of sundays
    february = 28
    for year in range(1901, 2001, 1):
        for ea in month_days:
            if a % 7 == 0:
                sun += 1
            m_d = 29 if ea == february and is_leap_year(year) else ea
            a += m_d
    return sun


def problem20():
    """Euler Problem 20.

    n! means nx(n-1)x...3x2x1
    For example 10! = 10*9*8*7*6*5*4*3*2*1 - 3628800
    and the sum of the digits in the number 10! is 3+6+2+8+8+0+0 = 27
    Find the sum of the digits in the number 100!
    """
    return sum(util.convert_int_to_list(util.calc_factorial(100)))


def problem21(max_val=10000):
    """Euler Problem 21.

    Let d(n) be defined as the sum of proper divisors of n (numbers less than n which divide evenly into n).
    If d(a) = b and d(b) = a, where a!=b, then a and b are an amicable pair and each of a and b are called amicable numbers.
    For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110; therefore d(220) = 284. The proper divisors of 284 are 1, 2, 4, 71 and 142; so d(284) = 220
    Evaluate the sum of all the amicable numbers under 10000.
    """
    amicable_set = set()
    for ea in range(max_val):
        if ea not in amicable_set:
            number_1 = ea
            number_2 = sum(util.find_all_divisors(ea))
            if sum(util.find_all_divisors(number_2)) == number_1 and number_1 != number_2:
                amicable_set.add(number_1)
                amicable_set.add(number_2)
    return sum(list(amicable_set))


def problem22():
    """Euler Problem 22.

    Using [data/0022_names.csv], a file containing over five-thousand first names, begin by sorting it into alphabetical order. Then working out the alphabetical value for each name, multiply this value by its alphabetical position in the list to obtain a name score.
    For example, when the list is sorted into alphabetical order, COLIN, which is worth 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in the list.
    So, COLIN would obtain a score of 938*53 = 49714.
    What is the total of all the name scores in the file?
    """

    def letter_scoring():
        letter_scores = {}
        letters = util.uppercase_letters
        for ea in range(len(letters)):
            letter_scores[letters[ea]] = ea + 1
        return letter_scores

    # Generate a dict of scores
    score_lookup = letter_scoring()
    names = util.import_data("data/0022_names.csv")[0]
    names.sort()
    total = 0

    # For each name, find the letter total. Then multiply letter by name number on the list
    for name_num in range(len(names)):
        letter_score = 0
        for letter in names[name_num]:
            letter_score += score_lookup.get(letter, 0)
        total += letter_score * (name_num + 1)
    return total


def problem23():
    """Euler Problem 23.

    A perfect number is a number for which the sum of its proper divisors is exactly equal to the number.
    For example, the sum of the proper divisors of 28 would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect number.
    A number n is called deficient if the sum of its proper divisors is less than n and it is called abundant if this sum exceeds n.
    As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the smallest number that can be written as the sum of two abundant numbers is 24.
    By mathematical analysis, it can be shown that all integers greater than 28123 can be written as the sum of two abundant numbers.
    However, this upper limit cannot be reduced any further by analysis even though it is known that the greatest number that cannot be expressed as the sum of two abundant numbers is less than this limit.
    Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.
    """

    def abundant_numbers(max_num=28123):
        return {ea for ea in range(max_num) if sum(util.find_all_divisors(ea)) > ea}

    def check_represented(n, abu):
        return any(n - ea in abu for ea in abu)

    tot = 0
    abundant_numbers_li = abundant_numbers(28123)
    for ea in range(1, 28123):
        if check_represented(ea, abundant_numbers_li):
            tot += ea
    return tot


def problem24(digits=None, idx=999999):
    """Euler Problem 24.

    A permutation is an ordered arrangement of objects. For example, 3124 is one possible permutation of the digits 1, 2, 3 and 4. If all of the permutations are listed numerically or alphabetically, we call it lexicographic order.
    The lexicographic permutations of 0, 1 and 2 are:
    012   021   102   120   201   210
    What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9?
    """
    if digits is None:
        digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    perms = list(permutations(digits))
    perms.sort()
    return perms[idx]


def problem25():
    """Euler Problem 25: 1000-digit Fibonacci number.

    The Fibonacci sequence is defined by the recurrence relation: Fn = Fn-1 + Fn-2, where F1 = 1 and F2 = 1.
    Hence the first 12 terms will be:
    F1 = 1
    F2 = 1
    F3 = 2
    F4 = 3
    F5 = 5
    F6 = 8
    F7 = 13
    F8 = 21
    F9 = 34
    F10 = 55
    F11 = 89
    F12 = 144
    The 12th term, F12, is the first term to contain three digits.
    What is the index of the first term in the Fibonacci sequence to contain 1000 digits?
    """

    def fibonacci_until_digits(number):
        """Generate list of fibonacci numbers until one has 'number' digits.

        Args:
            number (int): number of digits to reach

        Returns:
            list: list of fibonacci numbers

        """
        x = 1
        y = 2
        fib_list = [1, 2]
        while True:
            x, y = y, x + y
            fib_list.append(y)
            if len(str(y)) >= number:
                fib_list.append(y)
                break
        return fib_list

    return len(fibonacci_until_digits(1000))


def problem26():  # TODO(Kyle): #1 Troubleshoot errors.
    """Euler Problem 26: Reciprocal cycles.

    A unit fraction contains 1 in the numerator. The decimal representation of the unit fractions with denominators 2 to 10 are given:
    1/2	= 	0.5
    1/3	= 	0.(3)
    1/4	= 	0.25
    1/5	= 	0.2
    1/6	= 	0.1(6)
    1/7	= 	0.(142857)
    1/8	= 	0.125
    1/9	= 	0.(1)
    1/10	= 	0.1
    Where 0.1(6) means 0.166666..., and has a 1-digit recurring cycle. It can be seen that 1/7 has a 6-digit recurring cycle.
    Find the value of d < 1000 for which 1/d contains the longest recurring cycle in its decimal fraction part.
    """

    def find_reoccurring_section(numerator, denominator):
        if denominator == 0:
            return "Undefined"
        if numerator == 0:
            return 0

        remainder = numerator % denominator
        remainders = {}
        result = ""

        while remainder != 0 and remainder not in remainders:
            remainders[remainder] = len(result)  # store this remainder
            remainder *= 10  # bring down a zero
            result += str(remainder // denominator)  # add to decimal part
            remainder = remainder % denominator  # get new remainder

        return result[remainders[remainder] :] if remainder in remainders else ""

    reciprocal_cycles = {}
    for ea in range(1, 1000):
        current = len(find_reoccurring_section(1, ea))
        reciprocal_cycles[ea] = current
    return max(reciprocal_cycles, key=reciprocal_cycles.get)


def problem27(min_a=-999, max_a=999, max_b=1000):
    """Euler Problem 27: Quadratic primes.

    Euler discovered the remarkable quadratic formula:
    n^2 + n + 41
    It turns out that the formula will produce 40 primes for the consecutive integer values 0 ≤ n ≤ 39.
    However, when n = 40, 402 + 40 + 41 = 1681 = 41 x 41, which is not prime.
    The incredible formula n^2 - 79n + 1601 was discovered, which produces 80 primes for the consecutive values 0 ≤ n ≤ 79.
    The product of the coefficients, -79 and 1601, is -126479.

    Considering quadratics of the form:
    n^2 + an + b, where |a| < 1000 and |b| ≤ 1000
    where |n| is the modulus/absolute value of n
    e.g. |11| = 11 and |-4| = 4
    Find the product of the coefficients, a and b, for the quadratic expression that produces the maximum number of primes for consecutive values of n, starting with n = 0.
    """
    # Notes to self - if n=0, b must be prime.
    # For n=1, 1 + a + b must also be prime -> a must be even (since b is odd, except for 2)

    def evaluate(a, b):  # Evaluate number of primes for given a and b
        n = 1  # Start at 1 since n=0 is always prime (b is prime)
        while True:
            val = n**2 + a * n + b
            if val < 0 or util.is_prime(val) is False:
                return n
            n += 1

    n_primes = {}

    for a in [num for num in range(min_a, max_a) if num % 2 != 0]:  # a must be odd for n=1, so only do odd a
        for b in util.prime_list(max_b):  # b must be prime for n=0, so only do primes
            n_primes[f"{a},{b}"] = evaluate(a, b)  # Store number of primes for this a,b

    return max(n_primes, key=n_primes.get), n_primes.get(
        max(n_primes, key=n_primes.get),
    )  # Return a,b with max primes and number of primes that a,b has.


def problem28(size=1001):
    """Euler Problem 28: Number spiral diagonals.

    Starting with the number 1 and moving to the right in a clockwise direction a 5 by 5 spiral is formed as follows:
    21 22 23 24 25
    20  7  8  9 10
    19  6  1  2 11
    18  5  4  3 12
    17 16 15 14 13
    It can be verified that the sum of the numbers on the diagonals is 101.
    What is the sum of the numbers on the diagonals in a 1001 by 1001 spiral formed in the same way?
    """
    running_total = 1  # Ignore center
    last_number = 1  # Start at center
    # Each layer is increasingly far apart by 2. So layer is separated by 2 - 3, 5, 7, 9. Layer 2 is 4 separated, so 13, 17, 21, 25. This trend continues through whole spiral.
    for layer in range(1, size // 2 + 1):  # Each layer adds 2 to each side
        a = last_number + 2 * layer  # Each corner is 2*layer away from last
        b = a + 2 * layer
        c = b + 2 * layer
        d = c + 2 * layer
        running_total += a + b + c + d  # Add corners to total
        last_number = d  # Update last number to get ready for next layer
    return running_total


def problem29(min_val=2, max_val=100):
    """Euler Problem 29: Distinct powers.

    Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
    2^2=4, 2^3=8, 2^4=16, 2^5=32
    3^2=9, 3^3=27, 3^4=81, 3^5=243
    4^2=16, 4^3=64, 4^4=256, 4^5=1024
    5^2=25, 5^3=125, 5^4=625, 5^5=3125
    If they are then placed in numerical order, with any repeats removed, we get the following
    sequence of 15 distinct terms:
    4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
    How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
    """
    val_list = [a**b for a in range(min_val, max_val) for b in range(min_val, max_val)]
    return len(set(val_list))


def problem30(power=5):
    """Euler Problem 30: Digit fifth powers.

    Surprisingly there are only three numbers that can be written as the sum of fourth powers of their digits:
    1634 = 1^4 + 6^4 + 3^4 + 4^4
    8208 = 8^4 + 2^4 + 0^4 + 8^4
    9474 = 9^4 + 4^4 + 7^4 + 4^4
    As 1 = 1^4 is not a sum it is not included. The sum of these numbers is 1634 + 8208 + 9474 = 19316.
    Find the sum of all the numbers that can be written as the sum of fifth powers of their digits.
    """
    return sum([val for val in range(9, (1 + power) * (9**power)) if util.sum_digits_powers(val, 5) == val])


def problem30_alt(power=5):
    # Still need to investigate this one further to ensure it works as expected.
    li = []

    for digits in range(2, power + 2):
        for combo in combinations_with_replacement(range(10), digits):
            total = sum(int(ea) ** power for ea in combo)
            if sorted(map(int, str(total))) == sorted(combo):
                li.append(total)
    return li


def problem31(coin_target=200, coins=None):
    """Euler Problem 31: Coin sums.

    In England the currency is made up of pound (£) and pence (p). There are eight coins in general circulation:
    1p, 2p, 5p, 10p, 20p, 50p, £1 (100p) and £2 (200p).
    It is possible to make £2 in the following way:
    1x£1 + 1x50p + 2x20p + 1x5p + 1x2p + 3x1p
    How many different ways can £2 be made using any number of coins?
    """
    if coins is None:
        coins = [1, 2, 5, 10, 20, 50, 100, 200]
    ways = [0] * (coin_target + 1)  # Create list to hold number of ways to make each amount
    ways[0] = 1  # There is 1 way to make 0 amount

    for coin in coins:  # For each coin, update the ways to make each amount
        for amount in range(coin, coin_target + 1):  # For each amount that can be made with this coin
            ways[amount] += ways[amount - coin]

    return ways[coin_target]


def problem32():
    """Euler Problem 32: Pandigital products.

    We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once; for example, the 5-digit number 15234 is 1 through 5 pandigital.
    The product 7254 is unusual, as the identity 39 186 = 7254, containing multiplicand, multiplier, and product is 1 through 9 pandigital.
    Find the sum of all products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital.
    Hints:
    Some products can be obtained in more than one way so be sure to only include it once in your sum.
    """

    def list_to_num(digit_list):
        """Convert a list of digits to a number."""
        num = 0
        for digit in digit_list:
            num = num * 10 + digit
        return num

    def check_line(num_digits_first, num_digits_second, line):
        """Check if a line is valid pandigital product. Must be of form first * second = product. Does not check for pandigitalism."""
        first = line[:num_digits_first]
        second = line[num_digits_first : num_digits_first + num_digits_second]
        product = line[num_digits_first + num_digits_second :]
        return list_to_num(first) * list_to_num(second) == list_to_num(product)

    items = permutations([1, 2, 3, 4, 5, 6, 7, 8, 9], 9)  # All pandigital permutations of 1-9
    products = set()
    """
    Can ony be 2 forms - 1 digit * 4 digit = 4 digit, or 2 digit * 3 digit = 4 digit.
    Neither multiplier can have more digits than product. Reverses are the same as previous checks.

    1x2=6 - Not possible
    1x3=5 - Not possible
    1x4=4 - Valid
    2x1=6 - Not possible
    2x2=5 - Not possible
    2x3=4 - Valid
    3x2=4 - Same as 2x3=4, do not need to check again.
    4x1=4 - Same as 1x4=4, do not need to check again.
    """
    for item in items:
        if check_line(1, 4, item):
            products.add(int("".join(map(str, item[1 + 4 :]))))
        if check_line(2, 3, item):
            products.add(int("".join(map(str, item[2 + 3 :]))))
    return sum(products), len(products)


def problem33():
    """Euler Problem 33: Digit cancelling fractions.

    The fraction 49/98 is a curious fraction, as an inexperienced mathematician in attempting to simplify it may incorrectly believe that 49/98 = 4/8, which is correct, is obtained by cancelling the 9s.
    We shall consider fractions like, 30/50 = 3/5, to be trivial examples.
    There are exactly four non-trivial examples of this type of fraction, less than one in value, and containing two digits in the numerator and denominator.
    If the product of these four fractions is given in its lowest common terms, find the value of the denominator.
    """

    def shared_digit(num1, num2):
        num1str = util.convert_int_to_list(num1)
        num2str = util.convert_int_to_list(num2)
        return list(set(num1str).intersection(set(num2str)))

    def reduced(num, shared_digit):
        numstr = util.convert_int_to_list(num)
        return [x for x in numstr if x not in shared_digit]

    val = 1
    for top in range(1, 99):
        for bottom in range(top + 1, 100):
            digit = shared_digit(top, bottom)
            if len(digit) == 1 and digit != [0]:
                reduced_top = util.convert_list_to_int(reduced(top, digit))
                reduced_bottom = util.convert_list_to_int(reduced(bottom, digit))
                if reduced_top != 0 and reduced_bottom != 0 and reduced_top / reduced_bottom == top / bottom:
                    val *= reduced_top / reduced_bottom
    return 1 / round(val, 5)


def problem34():
    """Euler Problem 34: Digit factorials.

    145 is a curious number, as 1! + 4! + 5! = 1 + 24 + 120 = 145.  Find the sum of all numbers that are equal to the sum of the factorial of their digits.
    Note: as 1! = 1 and 2! = 2 are not sums they are not included.
    """
    digit_factorials = []

    for number in range(10, 7 * util.calc_factorial(9)):
        li = util.convert_int_to_list(number)
        val = 0
        for item in li:
            val += util.calc_factorial(item)
        if val == number:
            digit_factorials.append(number)
    return sum(digit_factorials)


def problem34_alt():
    """Euler Problem 33: Digit factorials. Alternate solution."""
    return sum([x for x in range(10, 10000000) if sum(map(util.calc_factorial, util.convert_int_to_list(x))) == x])


def problem35(max_val=1000000):
    """Euler Problem 35: Circular primes.

    The number, 197, is called a circular prime because all rotations of the digits: 197, 971, and 719, are themselves prime.
    There are thirteen such primes below 100: 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, and 97.
    How many circular primes are there below one million?
    """

    def is_circular_prime(prime):
        return all(util.is_prime(circular) for circular in util.generate_list_of_circulars(prime, return_type=int))

    circular_primes = [prime for prime in util.prime_list(max_val) if is_circular_prime(prime)]
    return len(circular_primes)


def problem36():
    """Euler Problem 36: Double-base palindromes.

    The decimal number, 585 = 10010010011 (binary), is palindromic in both bases.
    Find the sum of all numbers, less than one million, which are palindromic in base 10 and base 2.
    (Please note that the palindromic number, in either base, may not include leading zeros.)
    """
    return sum(
        [
            palindrome
            for palindrome in util.palindromes_list(1000000)
            if util.is_palindrome(util.convert_list_to_int(util.number_to_base(palindrome, 2)))
        ],
    )


def problem37():
    """Euler Problem 37: Truncatable primes.

    The number 3797 has the property that being truncated from left to right the sequence of digits is a prime.
    The number 3797 also has the property that being truncated from right to left the sequence of digits is a prime.
    Find the sum of the only eleven primes that are both truncatable from left to right and right to left.
    Note: 2, 3, 5, and 7 are not considered to be truncatable primes.
    """

    def check_trunc(prime):
        """Check if a prime is truncatable from left to right and right to left."""
        prime_str = str(prime)
        for i in range(1, len(prime_str)):
            if int(prime_str[i:]) not in primes:
                return False
            if int(prime_str[:i]) not in primes:
                return False
        return True

    primes = util.prime_list(1000000)
    answer_list = [prime for prime in primes if check_trunc(prime) and prime not in [2, 3, 5, 7]]
    return sum(answer_list)


def problem38():
    """Euler Problem 38: Pandigital multiples.

    Take the number 192 and multiply it by each of 1, 2, and 3: 192 x 1 = 192, 192 x 2 = 384, 192 x 3 = 576.
    By concatenating each product we get the 1 to 9 pandigital, 192384576.
    We will call 192384576 the concatenated product of 192 and each of 1, 2, and 3.
    The same can be achieved by starting with 9 and multiplying by  1, 2, 3, 4, and 5, giving the pandigital, 918273645, which is the concatenated product of 9 and each of 1, 2, 3, 4, and 5.
    What is the largest 1 to 9 pandigital 9-digit number that can be formed as the concatenated product of an integer with 1, 2, 3, 4, 5, 6, 7, 8, or 9?
    """

    def build_pandigital(num):
        item = ""
        for ea in (1, 2, 3, 4, 5, 6, 7, 8, 9):
            item += str(ea * num)
            if util.is_pandigital(item):
                return int(item)
        return 0

    max_val = 0
    for ea in range(1, 1000000):
        max_val = max(max_val, build_pandigital(ea))
    return max_val


def problem39():
    """Euler Problem 39: Integer right triangles.

    If p is the perimeter of a right angle triangle with integral length sides
    {a,b,c}, there are exactly three solutions for p = 120. {20,48,52}, {24,45,51}, {30,40,50}
    For which value of p ≤ 1000, is the number of solutions maximised?
    """
    solutions = {}

    for a in range(1, 1000):
        for b in range(a, (1000 - a)):
            for c in range(b, (1000 - a - b)):
                if util.triangle_check(a, b, c):
                    solutions[a + b + c] = solutions.get(a + b + c, 0) + 1
    return max(solutions, key=solutions.get)


def problem39_alt(max_len_of_wire=1000):
    """Euler Problem 39: Integer right triangles. Alternate solution.

    I went and looked up the wiki for Euclids formula to make it more efficient.
    """
    di = {}
    for m in range(2, int(max_len_of_wire**0.5) + 1): # Pythagorean triples
        for n in range(1, m):
            if (m - n) % 2 == 0 or util.gcd(m, n) != 1: # For primitive pythagorean triples, one of the two is even, and they are coprime
                continue
            # Pythagorean triples, from Euclids formula
            a, b, c = util.euclids_formula(m, n)
            perimeter = a + b + c # a + b + c = perimeter
            k = 1
            while k * perimeter <= max_len_of_wire: # Generate multiples of the primitive triple
                di[k * perimeter] = di.get(k * perimeter, 0) + 1
                k += 1
    return max(di, key=di.get)


def problem40():
    """Euler Problem 40: Champernowne's constant.

    An irrational decimal fraction is created by concatenating the positive integers:
    0.123456789101112131415161718192021...
    It can be seen that the 12th digit of the fractional part is 1.
    If dn represents the nth digit of the fractional part, find the value of the following expression.
    d1 x d10 x d100 x d1000 x d10000 x d100000 x d1000000
    """

    def create_champernownes(length):
        constant = ""
        i = 1
        while len(constant) < length:
            constant += str(i)
            i += 1
        return constant

    a = list(map(int, create_champernownes(1000000)))
    val = 1
    for ea in [1, 10, 100, 1000, 10000, 100000, 1000000]:
        val *= a[ea - 1]
    return val


def problem41():
    """Euler Problem 41: Pandigital prime.

    We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once. For example, 2143 is a 4-digit pandigital and is also prime.
    What is the largest n-digit pandigital prime that exists?
    """
    # 1+2+3+4+5+6+7+8+9 = 45, so divisible by 3
    # 1+2+3+4+5+6+7+8 = 36, so divisible by 3
    primes = util.prime_list(7654321)  # largest possible 7 digit pandigital prime would be 7654321
    for ea in primes[::-1]:  # Go from biggest to smallest, stop at first once, since that's the largest.
        if util.is_pandigital(str(ea)):
            return ea
    return None


def problem42():
    """Euler Problem 42: Coded triangle numbers.

    The nth term of the sequence of triangle numbers is given by, tn = ½n(n+1); so the first ten triangle numbers are:
    1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
    By converting the nth term, tn, to a string and sorting it into ascending order, find the values of the 3rd digit in the 2nd 5-digit number and the 4th digit in the 3rd 5-digit number.
    """
    letter_dict = {
        "A": 1,
        "B": 2,
        "C": 3,
        "D": 4,
        "E": 5,
        "F": 6,
        "G": 7,
        "H": 8,
        "I": 9,
        "J": 10,
        "K": 11,
        "L": 12,
        "M": 13,
        "N": 14,
        "O": 15,
        "P": 16,
        "Q": 17,
        "R": 18,
        "S": 19,
        "T": 20,
        "U": 21,
        "V": 22,
        "W": 23,
        "X": 24,
        "Y": 25,
        "Z": 26,
    }

    with Path("data/0042_words.txt").open() as f:
        words = f.read().split(",")

    triangle_numbers = [
        util.get_triangle_number(i) for i in range(1, len(max(words, key=len)) * 26)
    ]  # Calculate the triangle numbers up to the length of the longest word
    count_words = 0

    for word in words:
        fixed_word = word.replace('"', "").upper()
        if (
            sum([letter_dict[letter] for letter in fixed_word]) in triangle_numbers
        ):  # Check if the word is a triangle number
            count_words += 1
    return count_words


def problem43():
    """Euler Problem 43: Sub-string divisibility.

    The number, 1406357289, is a 0 to 9 pandigital number because it is made up of each of the digits 0 to 9 in some order, but it also has a rather interesting sub-string divisibility property.
    Let d1 be the 1st digit, d2 be the 2nd digit, and so on. In this way, we note the following:
    d2d3d4=406 is divisible by 2
    d3d4d5=063 is divisible by 3
    d4d5d6=635 is divisible by 5
    d5d6d7=357 is divisible by 7
    d6d7d8=572 is divisible by 11
    d7d8d9=728 is divisible by 13
    d8d9d10=289 is divisible by 17
    Find the sum of all 0 to 9 pandigital numbers with this property.
    """
    items = permutations([1, 2, 3, 4, 5, 6, 7, 8, 9, 0], 10)
    li = []
    for item in items:
        d24 = item[1] * 100 + item[2] * 10 + item[3]
        d35 = item[2] * 100 + item[3] * 10 + item[4]
        d46 = item[3] * 100 + item[4] * 10 + item[5]
        d57 = item[4] * 100 + item[5] * 10 + item[6]
        d68 = item[5] * 100 + item[6] * 10 + item[7]
        d79 = item[6] * 100 + item[7] * 10 + item[8]
        d80 = item[7] * 100 + item[8] * 10 + item[9]
        if (
            d24 % 2 == 0
            and d35 % 3 == 0
            and d46 % 5 == 0
            and d57 % 7 == 0
            and d68 % 11 == 0
            and d79 % 13 == 0
            and d80 % 17 == 0
        ):
            li.append(util.convert_list_to_int(item))
    return sum(li)


def problem44():  # TODO (Kyle): #3 IDK BRO, THIS TAKES FOREVER AND DOESNT WORK
    """Euler Problem 44: Pentagon numbers.

    Pentagonal numbers are generated by the formula, Pn=n(3n-1)/2. The first ten pentagonal numbers are:
    1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
    It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 - 22 = 48, is not pentagonal.
    Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal and D = |Pk - Pj| is minimised; what is the value of D?
    """

    def add(*args):
        return sum(args)

    def subtract(*args):
        return args[0] - args[1]

    def is_pentagonal_number(n):
        return 1 + (24 * n + 1) ** 0.5 % 6 == 0

    pentagonal_numbers = {util.get_pentagonal_number(i) for i in range(1, 1000000)}
    c = combinations(pentagonal_numbers, 2)
    for ea in c:
        if is_pentagonal_number(add(*ea)) and is_pentagonal_number(abs(subtract(*ea))):
            return int(subtract(*ea))
    return None


def problem45(min_num=40755):
    """Euler Problem 45: Triangular, pentagonal, and hexagonal.

    Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:
    Triangle - Tn=n(n+1)/2 - 1, 3, 6, 10, 15, ...
    Pentagonal - Pn=n(3n-1)/2 - 1, 5, 12, 22, 35, ...
    Hexagonal - Hn=n(2n-1) - 1, 6, 15, 28, 45, ...
    It can be verified that T285 = P165 = H143 = 40755.
    Find the next triangle number that is also pentagonal and hexagonal.
    """
    triangle_numbers = [util.get_triangle_number(i) for i in range(1, 100000)]
    pentagonal_numbers = [util.get_pentagonal_number(i) for i in range(1, 100000)]
    hexagonal_numbers = [util.get_hexagonal_number(i) for i in range(1, 100000)]
    shared = set(triangle_numbers).intersection(pentagonal_numbers, hexagonal_numbers)
    return min([x for x in shared if x > min_num])


def problem46():
    """Euler Problem 46: Goldbach's other conjecture.

    It was proposed by Christian Goldbach that every odd composite number can be written as the sum of a prime and twice a square.
    9 = 7 + 2x1^2, 15 = 7 + 2x2^2, 21 = 3 + 2x3^2, 25 = 7 + 2x2^2, etc.
    It turns out that the conjecture was false.
    Find the smallest odd composite that cannot be written as the sum of a prime and twice a square.
    """
    prime_list = util.prime_list(10000)
    squares = [x * x for x in range(1, 10000)]
    odd_composites = [x for x in range(2, 10000) if x % 2 == 1 and x not in prime_list]
    for prime in prime_list:
        for square in squares:
            if prime + 2 * square in odd_composites:
                odd_composites.remove(prime + 2 * square)
    return min(odd_composites)


def problem47(ct_unique_prime_factors=4):
    """Euler Problem 47: Distinct primes factors.

    The first two consecutive numbers to have two distinct prime factors are 14 and 15.
    The first three consecutive numbers to have three distinct prime factors are 644, 645 and 646.
    Find the first four consecutive integers to have four distinct prime factors. What is the first of these numbers?
    """
    li = []

    for i in range(1, 1000000):
        factors = util.prime_factors(i)
        if len(set(factors)) == ct_unique_prime_factors and util.multiply_list(*factors) == i:
            li.extend([i])
    sequential_counts = {}
    for i in range(len(li) - 1):
        count = 1
        for j in range(i + 1, len(li)):
            if li[j] == li[j - 1] + 1:
                count += 1
            else:
                break
        sequential_counts[li[i]] = count

    keys_with_value = [key for key, value in sequential_counts.items() if value == ct_unique_prime_factors]

    return min(keys_with_value)


def problem48():
    """Euler Problem 48: Self powers.

    The series, 1^1 + 2^2 + 3^3 + ... + 10^10
    is equal to 10405071317.
    Find the last ten digits of the series, 1^1 + 2^2 + 3^3 + ... + 1000^1000.
    """
    val = 0
    for ea in range(1, 1001):
        val += ea**ea
    return int(str(val)[-10:])


def problem49(digits=4, given_solution=(1487, 4817, 8147)):
    """Euler Problem 49: Prime permutations.

    The arithmetic sequence, 1487, 4817, 8147, in which each of the terms increases by 3330, is unusual in two ways:
    (i) each of the three terms are prime, and,
    (ii) each of the 4 digits of each number are permutations of one another.
    There are no arithmetic sequences made up of three primes from 1000 to 10000 that satisfy these properties.
    Find the sum of all the primes, below one million, that are also trigrams.
    """
    primes = util.prime_list(1000000)
    primes = [prime for prime in primes if len(str(prime)) == digits]
    for prime in primes:
        b = prime + 3330
        c = prime + 6660
        if (
            b in primes
            and c in primes
            and util.are_permutations(prime, b)
            and util.are_permutations(prime, c)
            and (prime, b, c) != given_solution
        ):
            return int(str(prime) + str(b) + str(c))
    return None


def problem50(under=1000000):
    """Euler Problem 50: Consecutive prime sum.

    The prime 41 can be written as the sum of six consecutive primes:
    41 = 2 + 3 + 5 + 7 + 11 + 13
    This is the longest sum of consecutive primes that adds to a prime below one-hundred.
    The longest sum of consecutive primes below one-thousand that adds to a prime, contains 21 terms, and is equal to 953.
    Which prime, below one-million, can be written as the sum of the most consecutive primes?
    """
    primes = util.prime_list(under)
    primes = [prime for prime in primes if prime < under]
    start = 0
    end = 0
    max_prime_so_far = 0
    num_of_primes_at_max = 0

    for start in range(len(primes)):
        for end in range(start, len(primes)):
            if sum(primes[start:end]) > under:
                break
            if sum(primes[start:end]) in primes and (end - start) > num_of_primes_at_max:
                num_of_primes_at_max = end - start
                max_prime_so_far = sum(primes[start:end])
    return num_of_primes_at_max, max_prime_so_far


def problem51(max_prime=1000000, prime_value_family_len=6):
    """Euler Problem 51: Prime digit replacements.

    By replacing the 1st digit of the 2-digit number *3, it turns out that six of the nine possible values: 13, 23, 43, 53, 73, and 83, are all prime.
    By replacing the 3rd and 4th digits of 56**3 with the same digit, this 5-digit number is the first example having seven primes among the ten generated numbers,
    yielding the family: 56003, 56113, 56333, 56443, 56663, 56773, and 56993. Consequently 56003, being the first member of this family, is the smallest prime with this property.
    Find the smallest prime which, by replacing part of the number (not necessarily adjacent digits) with the same digit, is part of an eight prime value family.
    """

    def prime_list(prime, mask, primes):
        digits = list(str(prime))
        new_numbers = [
            int("".join(str(replacement) if m else digit for digit, m in zip(digits, mask)))
            for replacement in range(1 if mask[0] else 0, 10)
        ]  # Generate all permuatations of this mask, replacing each True with 0-9.
        return list({x for x in new_numbers if x in primes})  # Return only list of primes

    primes = util.prime_list(max_prime)
    prime_set = set(primes)

    for prime in primes:
        digits = list(str(prime))
        masks = list(
            product([True, False], repeat=len(digits)),
        )  # Generates a list of all possible masks with True for replace and False for keep.
        for mask in masks:  # Iterates through all possible masks
            prime_new_numbers = prime_list(
                prime, mask, prime_set,
            )  # Generates a list of all possible prime numbers based on the given mask
            if len(prime_new_numbers) >= prime_value_family_len:  # If you hit the right length
                return min(prime_new_numbers)  # Return the smallest prime
    return None


def problem52():
    """Euler Problem 52: Permuted multiples.

    It can be seen that the number, 125874, and its double, 251748, contain exactly the same digits, but in a different order.
    Find the smallest positive integer, x, such that 2x, 3x, 4x, 5x, and 6x, contain the same digits.
    """

    def check_multiple(num, multiple):
        new_val = num * multiple
        if len(str(new_val)) != len(str(num)):  # Check same length
            return False
        return sorted(str(new_val)) == sorted(str(num))  # Check same digits

    i = 0
    while True:
        i += 1
        if all(
            check_multiple(i, value) for value in range(2, 6)
        ):  # Check if all multiples meet criteria. 2-6 because 1 is not a multiple.
            return i  # Return the smallest multiple


def problem53(max_n=100, combination_over=1000000):
    """Euler Problem 53: Combinatoric selections.

    There are exactly ten ways of selecting three from five, 12345:
    123, 124, 125, 134, 135, 145, 234, 235, 245, and 345
    In combinatorics, we use the notation, 5C3 = 10.
    In general,
    nCr = n! / r!(n-r)!
    where r ≤ n, n! = n *(n-1)*...*3*2*1, and 0! = 1.
    It is not until n = 23, that a value exceeds one-million: 23C10 = 1144066.
    How many, not necessarily distinct, values of nCr for 1 ≤ n ≤ 100, are greater than one-million?
    """
    i = 0
    for ea_n in range(1, max_n + 1):
        for ea_r in range(1, ea_n):
            if util.binomial_coefficient(ea_n, ea_r) > combination_over:
                i += 1
    return i


def problem54(text_file_path="p054_poker.txt"):
    """Euler Problem 54: Poker hands.

    In the card game poker, a hand consists of five cards and are ranked, from lowest to highest, in the following way:
    High Card: Highest value card.
    One Pair: Two cards of the same value.
    Two Pairs: Two different pairs.
    Three of a Kind: Three cards of the same value.
    Straight: All cards are consecutive values.
    Flush: All cards of the same suit.
    Full House: Three of a kind and a pair.
    Four of a Kind: Four cards of the same value.
    Straight Flush: All cards are consecutive values of same suit.
    Royal Flush: Ten, Jack, Queen, King, Ace, in same suit.
    The cards are valued in the order: 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King, Ace.

    If two players have the same ranked hands then the rank made up of the highest value wins; for example, a Straight Flush of 5Hearts beats a Straight Flush of 9Diamonds.

    If two ranks tie, the next highest ranked hand determines the winner, and so on; for example, 2 of a Kind beats 3 of a Kind (of any suit), and so on.

    The file, poker.txt, contains one-thousand random hands dealt to two players. Each line of the file contains ten cards (separated by a single space): the first five are Player 1's
    cards and the last five are Player 2's cards. You can assume that all hands are valid (no invalid characters or repeated cards), each player's hand is in no specific order, and in each hand there is a clear winner.
    How many hands does Player 1 win?
    """

    class Hand:
        def __init__(self, cards):
            self.card_value_dict = {
                "1": 1,
                "2": 2,
                "3": 3,
                "4": 4,
                "5": 5,
                "6": 6,
                "7": 7,
                "8": 8,
                "9": 9,
                "T": 10,
                "J": 11,
                "Q": 12,
                "K": 13,
                "A": 14,
            }
            self.card_suits = ["H", "D", "C", "S"]
            self.straight = "23456789TJQKA"
            self.royal_straight = "TJQKA"
            self.hand_rank = {
                "Royal flush": 1000,
                "Straight flush": 900,
                "Four of a kind": 800,
                "Full house": 700,
                "Flush": 600,
                "Straight": 500,
                "Three of a kind": 400,
                "Two pair": 300,
                "Pair": 200,
                "High card": 1,
            }
            self.card_groupings = {"Flush": 5, "Four of a kind": 4, "Three of a kind": 3, "Pair": 2}

            self.cards = cards
            self.card_values = []
            self.card_names = []
            self.card_suits = []
            self._get_cards()
            self.result = self._evaluate_hand()

        def _get_cards(self):
            for ea in self.cards:
                self.card_values.append(self.card_value_dict[ea[0]])
                self.card_suits.append(ea[1])
                self.card_names.append(ea[0])
            self.card_values.sort(reverse=True)
            self.card_suits.sort()
            self.card_names = "".join(
                sorted(util.convert_list_to_str(self.card_names), key=lambda x: self.card_value_dict[x]),
            )

        def _evaluate_hand(self):  # noqa: PLR0911
            most_common_card_ct = Counter(self.card_values).most_common(1)[0][1]
            second_common_card_ct = Counter(self.card_values).most_common(2)[1][1]
            most_common_card_value = Counter(self.card_values).most_common(1)[0][0]
            flush_check = Counter(self.card_suits).most_common(1)[0][1] == self.card_groupings["Flush"]
            straight_check = self.card_names in self.straight
            royal_check = self.card_names == self.royal_straight

            if royal_check and flush_check:
                return self.hand_rank["Royal flush"]
            if straight_check and flush_check:
                return self.hand_rank["Straight flush"] + most_common_card_value
            if most_common_card_ct == self.card_groupings["Four of a kind"]:
                return self.hand_rank["Four of a kind"] + most_common_card_value
            if (
                most_common_card_ct == self.card_groupings["Three of a kind"]
                and second_common_card_ct == self.card_groupings["Pair"]
            ):
                return self.hand_rank["Full house"] + most_common_card_value
            if flush_check:
                return self.hand_rank["Flush"]
            if straight_check:
                return self.hand_rank["Straight"] + most_common_card_value
            if most_common_card_ct == self.card_groupings["Three of a kind"]:
                return self.hand_rank["Three of a kind"]
            if (
                most_common_card_ct == self.card_groupings["Pair"]
                and second_common_card_ct == self.card_groupings["Pair"]
            ):
                return self.hand_rank["Two pair"]
            if most_common_card_ct == self.card_groupings["Pair"]:
                return self.hand_rank["Pair"] + most_common_card_value
            return max(self.card_values)

        def __str__(self):
            return f"{self.cards}, {self.result}"

    def tiebreaker(p1_hand, p2_hand):
        # Return True if p1_hand > p2_hand
        for card in range(5):
            if p1_hand.card_values[card] == p2_hand.card_values[card]:
                continue
            return p1_hand.card_values[card] > p2_hand.card_values[card]
        return False

    data = util.import_text_file(text_file_path)
    p1_wins = 0
    for line in data:
        hand = line.split()
        p1_hand = Hand(hand[:5])
        p2_hand = Hand(hand[5:])
        if p1_hand.result > p2_hand.result:
            p1_wins += 1
        if p1_hand.result == p2_hand.result and tiebreaker(p1_hand, p2_hand):
            p1_wins += 1

    return p1_wins


def problem55():
    """Euler Problem 55: Lychrel numbers.

    If we take 47, reverse and add, 47 + 74 = 121, which is palindromic.
    Not all numbers produce palindromes so quickly. For example,
    349 + 943 = 1292,
    1292 + 2921 = 4213
    4213 + 3124 = 7337
    That is, 349 took three iterations to arrive at a palindrome.
    Although no one has proved it yet, it is thought that some numbers, like 196, never produce a palindrome.
    A number that never forms a palindrome through the reverse and add process is called a Lychrel number. Due to the theoretical nature of these numbers, and for the purpose of this problem, we shall assume that a number is Lychrel until proven otherwise.
    In addition you are given that for every number below ten-thousand, it will either (i) become a palindrome in less than fifty iterations, or, (ii) no one, with all the computing power that exists,
    has managed so far to map it to a palindrome. In fact, 10677 is the first number to be shown to require over fifty iterations before producing a palindrome:
    4668731596684224866951378664 (53 iterations, 28-digits).

    Surprisingly, there are palindromic numbers that are themselves Lychrel numbers; the first example is 4994.

    How many Lychrel numbers are there below ten-thousand?

    Note: Wording was modified slightly on 24 April 2007 to emphasise the theoretical nature of Lychrel numbers.
    """

    def check_lychrel(n):
        n = str(n)
        for _ in range(50):
            n = str(int(n[::-1]) + int(n))
            if n == n[::-1]:
                return False
        return True

    lychrels = [lychrel for lychrel in range(10000) if check_lychrel(lychrel)]
    return len(lychrels)


def problem56():
    """Euler Problem 56: Powerful digit sum.

    A googol (10^100) is a massive number: one followed by one-hundred zeros; 100^100 is almost unimaginably large: one followed by two-hundred zeros. Despite their size, the sum of the digits in each number is only 1.
    Considering natural numbers of the form, a^b, where a, b < 100, what is the maximum digital sum?
    """
    val = 0
    for a in range(100):
        for b in range(100):
            val = max(sum(util.convert_int_to_list(a**b)), val)
    return val


def problem56_alt():
    # A bunch of list compression version of the above problem56
    return max([sum(util.convert_int_to_list(x)) for x in [a**b for a in range(100) for b in range(100)]])


def problem57(num=1000):
    """Euler Problem 57: Square root convergents.

    It is possible to show that the square root of two can be expressed as an infinite continued fraction.
    √ 2 = 1 + 1/(2 + 1/(2 + 1/(2 + ... ))) = 1.414213...
    By expanding this for the first four iterations, we get:
    1 + 1/2 = 3/2 = 1.5
    1 + 1/(2 + 1/2) = 7/5 = 1.4
    1 + 1/(2 + 1/(2 + 1/2)) = 17/12 = 1.41
    1 + 1/(2 + 1/(2 + 1/(2 + 1/2))) = 41/29 = 1.4142...
    The next three expansions are 99/70, 239/169, and 577/408, but the eighth expansion, 1393/985, is the first example where the number of digits in the numerator exceeds the number of digits in the denominator.
    In the first one-thousand expansions, how many fractions contain a numerator with more digits than the denominator?
    """

    def get_series_sqrt_2_series(num):
        li = [(3, 2)]
        for i in range(1, num):
            # each numerator = 2*previous demominator + previous numerator
            # each denominator = previous denominator + previous numerator
            prev_num = li[i - 1][0]
            prev_denom = li[i - 1][1]
            li.append((prev_num + 2 * prev_denom, prev_denom + prev_num))
        return li

    li = get_series_sqrt_2_series(num)
    return len([x for x in li if len(str(x[0])) > len(str(x[1]))])


def problem58(desired_ratio=0.1):
    """Euler Problem 58: Spiral primes.

    Starting with 1 and spiralling anticlockwise in the following way, a square spiral with side length 7 is formed.
    37 36 35 34 33 32 31
    38 17 16 15 14 13 30
    39 18  5  4  3 12 29
    40 19  6  1  2 11 28
    41 20  7  8  9 10 27
    42 21 22 23 24 25 26
    43 44 45 46 47 48 49
    It is interesting to note that the odd squares lie along the bottom right diagonal, but what is more interesting is that 8 out of the 13 numbers lying along both diagonals are prime; that is, a ratio of 8/13 ≈ 62%.
    If one complete new layer is wrapped around the spiral above, a square spiral with side length 9 will be formed.
    If this process is continued, what is the side length of the square spiral for which the ratio of primes along both diagonals first falls below 10%?
    """
    primes = 0
    side_len = 1
    num = 1
    prime_ratio = 1

    while prime_ratio >= desired_ratio:
        side_len += 2  # Sides grow by 2 each round
        for _ in range(4):
            num += side_len - 1  # Each number is side length - 1 away
            if util.is_prime(num):
                primes += 1
        prime_ratio = primes / (2 * side_len - 1)  # Ratio of primes to side length
    return side_len


def problem59():
    """Euler Problem 59: XOR decryption.

    Each character on a computer is assigned a unique code and the preferred standard is ASCII (American Standard Code for Information Interchange).
    For example, uppercase A = 65, asterisk (*) = 42, and lowercase k = 107.
    A modern encryption method is to take a text file, convert the bytes to ASCII, then XOR each byte with a given value, taken from a secret key.
    The advantage with the XOR function is that using the same encryption key on the cipher text, restores the plain text; for example, 65 XOR 42 = 107, then 107 XOR 42 = 65.

    For unbreakable encryption, the key is the same length as the plain text message, and the key is made up of random bytes.
    The user would keep the encrypted message and the encryption key in different locations, and without both "halves", it is impossible to decrypt the message.

    Unfortunately, this method is impractical for most users, so the modified method is to use a password as a key.
    If the password is shorter than the message, which is likely, the key is repeated cyclically throughout the message.
    The balance for this method is using a sufficiently long password key for security, but short enough to be memorable.

    Your task has been made easy, as the encryption key consists of three lower case characters.
    The first letter of the password, if any, is 'a'; the second is 'b' and the third is 'c'.
    Using p059_cipher.txt (right click and 'Save Link/Target As...'), a file containing the encrypted ASCII codes, and the knowledge that the plain text must contain common English words, decrypt the message and find the sum of the ASCII values in the original text.
    """

    def allowed_char(character):
        return character in range(
            32, 123,
        )  # no idea what the range is, but at least this covers all upper & lower case with numbers.

    def check_common_words(translated_text):
        return bool(
            " the " in translated_text or " of " in translated_text or " and " in translated_text,
        )  # They said common words, so

    ascii_lowercase = range(97, 123)
    text = [int(x) for x in util.import_data("data/0059_cipher.txt")[0]]
    possible_codes = {}
    for a in ascii_lowercase:  # Loop through the lowercase letters
        for b in ascii_lowercase:  # and again
            for c in ascii_lowercase:  # ... and again.
                lowercase_key = (
                    (chr(a) + chr(b) + chr(c)) * len(text)
                )  # Generate the key, since it's "repeated cyclically throughout the message", we can just multiply by the length of the text.
                decrypted = []
                """Slower version (no loop breaks) can use list compression. Replaces the "for count, i in enumerate(text)" loop:
                decrypted = [util.xor(y,ord(lowercase_key[x])) for x,y in enumerate(text) if allowed_char(util.xor(y,ord(lowercase_key[x])))]
                """
                for count, i in enumerate(text):  # For each character in the text
                    temp = util.xor(i, ord(lowercase_key[count]))  # See if the character is allowed
                    if not allowed_char(temp):
                        break  # Speeds things up a bit
                    decrypted.append(temp)  # If it is, add it to the decrypted text
                if len(decrypted) == len(text):  # If the decrypted text is the same length as the text, it worked!
                    finaltext = "".join(chr(x) for x in decrypted)
                    if not check_common_words(finaltext):  # Check if it's got a common word
                        continue
                    total = sum(decrypted)
                    possible_codes[lowercase_key[:3]] = (total, finaltext)
    return possible_codes  # Need to check that there's only 1 possible key based on output.


def problem60():  # TODO(Kyle): #5
    """Euler Problem 60: Prime pair sets.

    The primes 3, 7, 109, and 673, are quite remarkable. By taking any two primes and concatenating them in any order the result will always be prime.
    For example, taking 7 and 109, both 7109 and 1097 are prime. The sum of these four primes, 792, represents the lowest sum for a set of four primes with this property.
    Find the lowest sum for a set of five primes for which any two primes concatenate to produce another prime.
    """

    def evaluate_set(combo):
        return all(util.is_prime(int(f"{p[0]}{p[1]}")) for p in list(permutations(combo, 2)))

    primes = util.prime_list(10000)
    for a in primes:
        print(a)
        for b in [x for x in primes if x > a]:
            if evaluate_set([a, b]):
                for c in [x for x in primes if x > b]:
                    if evaluate_set([a, b, c]):
                        for d in [x for x in primes if x > c]:
                            if evaluate_set([a, b, c, d]):
                                for e in [x for x in primes if x > d]:
                                    if evaluate_set([a, b, c, d, e]):
                                        return sum([a, b, c, d, e]), [a, b, c, d, e]
                                continue
                            continue
                        continue
                    continue
                continue
            continue
        continue
    return None


def problem61():  # TODO(Kyle): #6
    """Euler Problem 61: Cyclical figurate numbers.

    Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
    Triangle - P3,n=n(n+1)/2 - 1, 1, 3, 6, 10, 15, ...
    Square - P4,n=n^2 - 1, 1, 4, 9, 16, 25, ...
    Pentagonal - P5,n=n(3n-2) - 1, 1, 5, 12, 22, 35, ...
    Hexagonal - P6,n=n(2n-1) - 1, 1, 6, 15, 28, 45, ...
    Heptagonal - P7,n=n(5n-3) - 1, 1, 7, 18, 34, 55, ...
    Octagonal - P8,n=n(3n-2) - 1, 1, 8, 21, 40, 65, ...
    The first ten characters of each figurate number are: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
    By concatenating the two, the sequence of four numbers: 8128, 2882, 8281, 2181, forms a cyclical 5-gon (P45678).
    Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
    """

    def generate_list(func, max_val, digits=4):
        i = 1
        items = []
        while func(i) < max_val:
            f = str(int(func(i)))
            if len(str(f)) == digits:
                items.append(f)
            i += 1
        return items

    def cyclic(x, y):
        return x[-2:] == y[:2]

    groups = [
        generate_list(x, 10000)
        for x in [
            util.get_triangle_number,
            util.get_square_number,
            util.get_pentagonal_number,
            util.get_hexagonal_number,
            util.get_heptagonal_number,
            util.get_octagonal_number,
        ]
    ]

    combos = list(permutations(range(6), 6))
    # Check at each level if it's a cyclic number or not to reduce the total checks.
    # Also iterate over all the permutations of order, to find the one that works.
    for li in combos:
        for item_one in groups[li[0]]:
            for item_two in groups[li[1]]:
                if cyclic(item_one, item_two):
                    for item_three in groups[li[2]]:
                        if cyclic(item_two, item_three):
                            for item_four in groups[li[3]]:
                                if cyclic(item_three, item_four):
                                    for item_five in groups[li[4]]:
                                        if cyclic(item_four, item_five):
                                            for item_six in groups[li[5]]:
                                                if (
                                                    cyclic(item_five, item_six) and cyclic(item_six, item_one)
                                                ):  # and len({item_one, item_two, pen, hexagonal, hep, octagonal}) == 6:
                                                    return sum(
                                                        [
                                                            int(x)
                                                            for x in [
                                                                item_one,
                                                                item_two,
                                                                item_three,
                                                                item_four,
                                                                item_five,
                                                                item_six,
                                                            ]
                                                        ],
                                                    )
    return None


def problem62(num_cubes_needed=5):
    """Euler Problem 62: Cubic permutations.

    The cube, 41063625 (3453), can be permuted to produce two other cubes: 56623104 (3843) and 66624900 (4680).
    Find the smallest cube for which exactly five permutations of its digits are cube.
    """

    def generate_cube(n):
        return n * n * n

    di = {1: [1]}
    i = 1
    # Create a growing dictionary, where the keys are the digits of the cubes, and the values are the numbers that were cubed. When the list hits num_cubes_needed, stop
    while max(len(value) for value in di.values()) < num_cubes_needed:
        next_cube = generate_cube(i)
        next_cube_sort = "".join(sorted(str(next_cube)))
        di.setdefault(next_cube_sort, []).append(i)
        i += 1
    # Return the smallest cube, by finding the smallest item of the largest list & cubing it.
    return generate_cube(min(max(di.values(), key=len)))


def problem62_alt(num_cubes_needed=5):
    # Better performing version. Why store as a dict when a list will do?
    def generate_cube(n):
        return n * n * n

    li = [0]
    i = 1
    while True:
        next_cube = generate_cube(i)
        next_cube_sort = "".join(sorted(str(next_cube)))
        li.append(next_cube_sort)

        if li.count(next_cube_sort) == num_cubes_needed:
            return generate_cube(li.index(next_cube_sort))
        i += 1


def problem63():
    """Euler Problem 63: Powerful digit counts.

    The 5-digit number, 16807=7^5, is also a fifth power. Similarly, the 9-digit number, 134217728=8^9, is a ninth power.
    How many n-digit positive integers exist which are also an nth power?
    """

    def check_power(base, power):
        return len(util.convert_int_to_list(base**power)) == power

    tot = 0
    for b in range(1, 100):
        for p in range(1, 100):
            if check_power(base=b, power=p):
                tot += 1
    return tot


def problem64(max_n=10_000):
    """Euler Problem 64: Odd period square roots.

    All square roots are periodic when written as continued fractions and can be written in the form:
    √N = a0 + 1/(a1 + 1/(a2 + 1/(a3 + ... )))
    For example, let us consider √23:
    √23 = 4 + √23 - 4 = 4 + 1/(1/(√23 - 4))
    If we continue we would get the following expansion:
    √23 = 4 + 1/(1 + 1/(3 + 1/(1 + 1/(8 + ... )))))
    The process can be summarised as follows:
    a0 = 4, 1/(√23 - 4) = 1/(1 + 1/(3 + 1/(1 + 1/(8 + ... )))))
    a1 = 1 + 1/(3 + 1/(1 + 1/(8 + ... )))))
    a2 = 3 + 1/(1 + 1/(8 + ... )))))
    a3 = 1 + 1/(8 + ... )))))
    a4 = 8 + ...
    It can be seen that the sequence is repeating. For conciseness, we use the notation √23 = [4;(1,3,1,8)] to mean that the block (1,3,1,8) repeats indefinitely.
    The first ten continued fraction representations of (irrational) square roots are:
    √2 = [1;(2)]
    √3 = [1;(1,2)]
    √5 = [2;(4)]
    √6 = [2;(2,4)]
    √7 = [2;(1,1,1,4)]
    √8 = [2;(1,4)]
    √10 = [3;(6)]
    √11 = [3;(3,6)]
    √12 = [3;(2,6)]
    √13 = [3;(1,1,1,1,6)]
    Exactly four continued fractions below N=13 have an odd period.
    How many continued fractions for N ≤ 10000 have an odd period?
    """
    odds = 0
    for i in range(1, max_n+1):
        _, cf = util.continued_fraction_sqrt(i)
        if len(cf) % 2 == 1:
            odds += 1
    return odds


def problem65(limit=100):
    """Euler Problem 65: Convergents of e.

    The square root of 2 can be written as an infinite continued fraction.
    √2 = 1 + 1/(2 + 1/(2 + 1/(2 + ... ))) = 1.414213...
    The infinite continued fraction can be written, √2 = [1;(2)], (2) indicates that 2 repeats ad infinitum.
    In a similar way, √23 = [4;(1,3,1,8)].
    It turns out that the sequence of partial values of continued fractions for square roots provide the best rational approximations. Let us consider the convergents for √2.
    1 + 1/2 = 3/2
    1 + 1/(2 + 1/2) = 7/5
    1 + 1/(2 + 1/(2 + 1/2)) = 17/12
    1 + 1/(2 + 1/(2 + 1/(2 + 1/2))) = 41/29
    Hence the sequence of the first ten convergents for √2 are:
    1, 3/2, 7/5, 17/12, 41/29, 99/70, 239/169, 577/408, 1393/985, 3363/2368, ...
    What is most surprising is that the important mathematical constant,
    e = [2; 1,2,1, 1,4,1, 1,6,1 , ... , 1,2k,1 , ...].
    The first ten terms in the sequence of convergents for e are:
    2, 3, 8/3, 11/4, 19/7, 87/32, 106/39, 193/71, 1264/465, 1457/536, ...
    The sum of digits in the numerator of the 10th convergent is 1+4+5+7=17. Find the sum of digits in the numerator of the 100th convergent of the continued fraction for e.
    """
    e = [2]
    i = 1
    while len(e) < limit:
        e += [1, i*2, 1]
        i += 1
    e = e[0:limit]
    e.reverse()
    numerator, denominator = 1, e[0]

    for x in range(1,limit):
        numerator, denominator = denominator, e[x]*denominator + numerator

    return util.sum_digits_powers(denominator,1)


def problem66(max_d=1000):
    """Euler Problem 66: Diophantine equation.

    Consider quadratic Diophantine equations of the form:
    x^2 - Dy^2 = 1
    For example, when D=13, the minimal solution in x is 67^2 - 13*8^2 = 1.
    Find the minimal solution in x for D ≤ 1000.
    """
    di = {}
    for d in range(2, max_d):
        di[d] = util.pell(d)[0] #For each d, get the numerator of the fundamental solution
    return max(di, key=di.get) #Return the d with the largest numerator


def problem67(filename="data/0067_triangle.csv"):
    """Euler Problem 67.

    By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.
    Find the maximum total from top to bottom in [data/0067_triangle.csv], a file containing a triangle with one-hundred rows.
    Note: This is a much more difficult version of Problem 18. It is not possible to try every route to solve this problem, as there are 2^99 altogether!
    If you could check one trillion (10^12) routes every second it would take over twenty billion years to check them all. There is an efficient algorithm to solve it.
    """
    return problem18(filename)  # Already solved it in problem 18.


def problem68(): #TODO(Kyle): #11 Complete
    return None


def problem69(max_n=1000000):
    """Euler Problem 69: Totient maximum.

    Euler's Totient function, φ(n) [sometimes called the phi function], is used to determine the number of numbers less than n which are relatively prime to n.
    For example, as 1, 2, 4, 5, 7, and 8, are all less than nine and relatively prime to nine, φ(9)=6.
    It can be seen that n=6 produces a maximum n/φ(n) for n ≤ 10.
    Find the value of n ≤ 1000000 for which n/φ(n) is a maximum.
    """
    di = {}
    for n in range(1, max_n+1):
        di[n] = n/util.eulers_totient(n) # Calculate n/φ(n) and store in dictionary
    return max(di, key=di.get) # Return the key with the highest value


def problem70(max_value=10000000):
    """Euler Problem 70: Totient permutation.

    Euler's Totient function, φ(n), is used to determine the number of numbers less than n which are relatively prime to n.
    For example, as 1, 2, 4, 5, 7, and 8, are all less than nine and relatively prime to nine, φ(9)=6.
    Surprisingly, φ(87109)=79180, and it can be seen that 87109 is a permutation of 79180.
    Find the value of n, 1 < n < 10^7, for which φ(n) is a permutation of n and the ratio n/φ(n) produces a minimum.
    """
    di = {}
    primes = util.prime_list(max_value//1000) # Generate a list of primes, up to max_value/1000 to ensure n=x*y is less than max_value.
    #To maximize the ratio n/φ(n), n must be the product of two distinct primes. So we only check those.
    for x in primes:
        for y in [y for y in primes if x < y]: # Ensure distinct primes, and x < y to avoid double checking
            n = x * y
            if n > max_value: # If n is too large, skip
                continue
            t = (x - 1) * (y - 1) # Calculate φ(n)
            if util.are_permutations(n, t): # Check if n and φ(n) are permutations
                di[n] = n / t # Store n/φ(n) in dictionary
    return min(di, key=di.get) # Return the key with the lowest value


def problem71(max_d=1000000, target_fraction=(3, 7)): #TODO(Kyle): #12 Should be able to do this without the for loop on n?
    """Euler Problem 71: Ordered fractions.

    Consider the fraction, n/d, where n and d are positive integers. If n<d and HCF(n,d)=1, it is called a reduced proper fraction.
    If we list the set of reduced proper fractions for d ≤ 8 in ascending order of size, we get:
    1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8
    It can be seen that 2/5 is the fraction immediately to the left of 3/7.
    By listing the set of reduced proper fractions for d ≤ 1,000,000 in ascending order of size, find the numerator of the fraction immediately to the left of 3/7.
    """
    left_fraction = ((target_fraction[0]-1)/(target_fraction[1]+1), target_fraction)
    for d in range(1, max_d + 1): # Go through all denominators
        max_n = int(target_fraction[0]*d/target_fraction[1]) # Largest n where n/d < 3/7
        min_n = int(left_fraction[0]*d) # Smallest n where n/d >= 2/5
        for n in reversed(range(min_n, max_n)): #use the biggest, since it'll be closest to 3/7
            if left_fraction[0]<(n/d): # If n/d is closer to target_fraction than left_fraction
                left_fraction = (n/d, util.reduce_fraction(n, d)) # Use it
            continue
    return left_fraction[1]


def problem72(max_d=1000000):
    """Euler Problem 72: Counting fractions in a range.

    Consider the fraction, n/d, where n and d are positive integers. If n<d and HCF(n,d)=1, it is called a reduced proper fraction.
    If we list the set of reduced proper fractions for d ≤ 8 in ascending order of size, we get:
    1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8
    It can be seen that there are 21 elements in this set.
    How many elements would be contained in the set of all reduced proper fractions for d ≤ 1,000,000?
    """
    x = 0
    for d in range(2,max_d+1): #Go through all denominators
        x+=util.eulers_totient(d) #Number of reduced proper fractions for denominator d is φ(d)
    return x


def problem73(max_d=12000, lower_fraction=(1, 3), upper_fraction=(1, 2)):
    """Euler Problem 73: Counting fractions in a range.

    Consider the fraction, n/d, where n and d are positive integers. If n<d and HCF(n,d)=1, it is called a reduced proper fraction.
    If we list the set of reduced proper fractions for d ≤ 8 in ascending order of size, we get:
    1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8
    It can be seen that there are 3 fractions between 1/3 and 1/2.
    How many fractions lie between 1/3 and 1/2 for d ≤ 12000?
    """
    li = []
    for d in range(1, max_d + 1): # Go through all denominators
        max_n = int(upper_fraction[0]*d/upper_fraction[1])+1
        min_n = int(lower_fraction[0]*d/lower_fraction[1])
        for n in range(min_n, max_n):
            if n/d > lower_fraction[0]/lower_fraction[1] and n/d < upper_fraction[0]/upper_fraction[1]:
                if util.reduce_fraction(n, d) != (n, d):
                    continue
                li.append((n/d, util.reduce_fraction(n, d)))
    return len(li)

def problem74(max_starting_val=1000000, chain_length=60):
    """Euler Problem 74: Digit factorial chains.

    The number 145 is well known for the property that the sum of the factorial of its digits is equal to 145:
    1! + 4! + 5! = 1 + 24 + 120 = 145
    Perhaps less well known is 169, in that it produces the longest chain of numbers that link back to 169 itself:
    169 → 363601 → 1454 → 169
    It is not difficult to prove that EVERY starting number will eventually get stuck in a loop. For example,
    69 → 363600 → 1454 → 169 → 363601 (→ 1454)
    78 → 45360 → 871 → 45361 → 871
    540 → 145 (→ 145)
    Starting with 69 produces a chain of five non-repeating terms, but the longest non-repeating chain with a starting number below one million is sixty terms.
    How many chains, with a starting number below one million, contain exactly sixty non-repeating terms?
    """
    def find_chain_length(x):
        loop_val = x
        chain = [x]
        while True:
            fd = util.factorial_digits(loop_val)
            if fd in chain:
                break
            chain.append(fd)
            loop_val = fd
        return len(chain)

    di = {}
    for loop_val in range(1, max_starting_val):
        chain_len = find_chain_length(loop_val)
        di[chain_len] = di.get(chain_len, 0) + 1
    return di.get(chain_length, 0)


def problem74_alt(max_starting_val=1000000, chain_length=60):
    """Alternate solution to problem 74.

    Slightly faster. I saw someone mention a 'fingerprint', and it reminded me that the order of digits doesn't matter for factorial digit sums.
    So we can cache the factorial digit sums based on the sorted string of digits, rather than recalculating each permutation every time.
    """
    di = {} # Cache for factorial digit sums
    total = 0
    for ea in range(1, max_starting_val):
        loop_val = ea
        chain = [ea]
        while True:
            str_fd = "".join(sorted(str(loop_val))) # The order of the digits doesn't matter, so why bother recalculating each permutation?
            if str_fd not in di:
                di[str_fd] = util.factorial_digits(loop_val) # Calculate and store if not already done
            fd = di[str_fd]
            if fd in chain:
                break
            chain.append(fd)
            loop_val = fd
        if chain_length == len(chain):
            total+=1
    return total


def problem75(max_len_of_wire=1500000):
    """Euler Problem 75: Singlular integer right triangles.

    It turns out that 12 cm is the smallest length of wire that can be bent to form an integer sided right triangle in exactly one way, but there are many more examples.
    12 cm: (3,4,5)
    24 cm: (6,8,10)
    30 cm: (5,12,13)
    36 cm: (9,12,15)
    40 cm: (8,15,17)
    48 cm: (12,16,20)

    In contrast, some lengths of wire, like 20 cm, cannot be bent to form an integer sided right triangle, and other lengths allow more than one solution to be found; for example, using 120 cm it is possible to form exactly three different integer sided right triangles.
    120 cm: (30,40,50), (20,48,52), (24,45,51)
    Given that L is the length of the wire, for how many values of L ≤ 1500000 can exactly one integer sided right triangle be formed?
    """
    di = {}
    for m in range(2, int(max_len_of_wire**0.5) + 1): # Pythagorean triples
        for n in range(1, m):
            if (m - n) % 2 == 0 or util.gcd(m, n) != 1: # For primitive pythagorean triples, one of the two is even, and they are coprime
                continue
            # Pythagorean triples, from Euclids formula
            a, b, c = util.euclids_formula(m, n)
            perimeter = a + b + c # a + b + c = perimeter
            k = 1
            while k * perimeter <= max_len_of_wire: # Generate multiples of the primitive triple
                di[k * perimeter] = di.get(k * perimeter, 0) + 1
                k += 1
    return sum(1 for x in di.values() if x == 1)


def problem76(target=100):
    """Euler Problem 76: Counting summations.

    It is possible to write five as a sum in exactly six different ways:

    4 + 1
    3 + 2
    3 + 1 + 1
    2 + 2 + 1
    2 + 1 + 1 + 1
    1 + 1 + 1 + 1 + 1

    How many different ways can one hundred be written as a sum of at least two positive integers?
    """
    #This is basically the same as the coin problem, except with all numbers.
    ways = [0] * (target + 1)  # Create list to hold number of ways to make each amount
    ways[0] = 1  # There is 1 way to make 0 amount
    for val in range(1, target): # For each value, update the ways to make each amount
        for amount in range(val, target + 1):  # For each amount that can be made with this value
            ways[amount] += ways[amount - val]
    return ways[-1]


def problem77(ways_target=5000):
    """Euler Problem 77: Prime summations.

    It is possible to write ten as the sum of primes in exactly five different ways:

    7 + 3
    5 + 5
    5 + 3 + 2
    3 + 3 + 2 + 2
    2 + 2 + 2 + 2 + 2

    What is the first value which can be written as the sum of primes in over five thousand ways?
    """
    # This is basically the same as the coin problem, except with primes. I limited it to 2x the amount of ways, since it expands so quickly.
    primes = util.prime_list(ways_target)  # Get list of primes
    ways = [0] * (ways_target + 1)  # Create list to hold number of ways to make each amount
    ways[0] = 1  # There is 1 way to make 0 amount

    for prime in primes:
        for amount in range(prime, len(ways)):
            ways[amount] += ways[amount - prime]

    return min([x for x in range(len(ways)) if ways[x] > ways_target]) # Get the first amount with more than 5000 ways


def problem78(modulus_to_check=1000000): #TODO(Kyle): #13 Refactor
    """Euler Problem 78: Prime summations (again).

    Let p(n) represent the number of different ways in which n coins can be separated into piles. For example, five coins can be separated into piles in exactly seven different ways, so p(5)=7.
    Find the least value of n for which p(n) is divisible by one million.
    """
    def generate_euler_pentagonal(k, s):
        return k*(3*k + s)//2

    def summation(p, n, pent):
        summ = 0
        for k, v in enumerate(pent):
            if v <= n:
                summ += p[n-v] * (1-(k&2))
            else:
                break
        return summ

    pent = [generate_euler_pentagonal(k,s) for k in range(1,202) for s in(-1,1)]
    p = [1]
    for n in range(1,60001):
        p.append(summation(p, n, pent))
        if p[n] % modulus_to_check == 0:
            return n
    return None


def problem79(filename="data/0079_keylog.txt"):
    """Euler Problem 79: Passcode derivation.

    A common security method used for online banking is to ask the user for three random characters from a passcode.
    For example, if the passcode was 531278, they may ask for the 2nd, 3rd, and 5th characters; the expected reply would be: 317.
    The text file, keylog.txt, contains fifty successful login attempts.
    Given that the three characters are always asked for in order, analyse the file so as to determine the shortest possible secret passcode of unknown length.
    """
    def check_match(x, y):
        fnmatch.fnmatch(x, f"""*{"*".join(list(y))}*""") #Returns true if y is a substring of x, uses wildcards.

    data = [x.strip() for x in util.import_text_file(filename)] #I hate whitespace

    for pp in list(permutations({x for y in data for x in y if x in util.digits})): #Get all possible passcodes
        possible_password = "".join(pp)
        if sum([1 for key in data if check_match(possible_password, key)]) == len(data): #Check if the passcode is valid by checking each key is a wildcard match.
            return possible_password
    return None


def problem79_alt(filename="data/0079_keylog.txt"):
    data = util.import_text_file(filename)
    digits = {x for y in data for x in y if x in util.digits}
    perms = list(permutations(digits))

    for possible_passcode in perms:
        pp = "".join(possible_passcode)
        x = 0
        for code in data:
            if pp.index(code[0]) < pp.index(code[1]) <pp.index(code[2]):
                x+=1
            else:
                break
        if x == len(data):
            return pp
    return None


def problem80(max_int=100, prec=100):
    """Euler Problem 80: Square root digital expansion.

    It is well known that if the square root of a natural number is not an integer, then it is irrational. The decimal expansion of such square roots is infinite without any repeating pattern at all.
    The square root of two is 1.41421356237309504880..., and the digital sum of the first one hundred decimal digits is 475.
    For the first one hundred natural numbers, find the total of the digital sums of the first one hundred decimal digits for all the irrational square roots.
    """
    values = [x for x in range(max_int+1) if int(x**0.5) != x**0.5]
    tot = 0
    for value in values:
        tot += sum([int(x) for x in util.sqrt_by_subtraction(value, prec)])
    return tot


def problem81(filename="data/0081_matrix.txt"):
    """Euler Problem 81: Path sum: two ways.

    In the 5 by 5 matrix below, the minimal path sum from the top left to the bottom right, by only moving to the right and down, is indicated in bold red and is equal to 2427.
    Find the minimal path sum from the top left to the bottom right by only moving right and down in [data/0081_matrix.txt], a 31K text file containing an 80 by 80 matrix.
    """
    matrix = util.import_2d_array_data(filename)
    output_matrix = [[0]*len(matrix[0])]*len(matrix)

    #Go through the matrix, starting at upper left & taking min of up & left all the way to the bottom. If no upper? Left. If no left? Up. If neither? Start.
    for x in range(len(matrix)):
        for y in range(len(matrix[x])):
            if x - 1 >= 0 and y - 1 >= 0: #Take min of up & left
                output_matrix[x][y] = matrix[x][y] + min(output_matrix[x-1][y], output_matrix[x][y-1])
            elif x - 1 >= 0: #If no left, take up
                output_matrix[x][y] = matrix[x][y] + output_matrix[x-1][y]
            elif y - 1 >= 0: #If no up, take left
                output_matrix[x][y] = matrix[x][y] + output_matrix[x][y-1]
            else: #Starting Point
                output_matrix[x][y] = matrix[x][y]
    return output_matrix[x][y]


def problem82(filename="data/0082_matrix.txt"):
    """Euler Problem 82: Path sum: three ways.

    The minimal path sum in the 5 by 5 matrix below, by starting in any cell in the left column and finishing in any cell in the right column, and only moving up, down and right, is indicated in red and is equal to 994.
    Find the minimal path sum from the left column to the right column in [data/0082_matrix.txt], a 31K text file containing a 80 by 80 matrix.
    """
    def mindistance(ref_x, ref_y):
        lengths = []
        up_curr = 0
        down_curr = 0

        for i in range(1, len(matrix)):
            # Check up
            up = ref_x - i
            if up >= 0:
                up_curr += matrix[up][ref_y]
                lengths.append(up_curr + mask[up][ref_y-1])
            # Check down
            down = ref_x + i
            if down < len(matrix):
                down_curr += matrix[down][ref_y]
                lengths.append(down_curr + mask[down][ref_y-1])
        # Check left
        lengths.append(mask[ref_x][ref_y-1])

        return min(lengths) # Pick the shortest

    matrix = util.import_2d_array_data(filename)
    mask = util.generate_2d(len(matrix), len(matrix[0]), 0)
    for col in range(len(matrix[0])):
        for row in range(len(matrix)):
            mask[row][col] += matrix[row][col] + mindistance(row, col)
    return min(mask[row][-1] for row in range(len(matrix)))


def problem83(filename="data/0083_matrix.txt"):
    """Euler Problem 83: Path sum: four ways.

    In the 5 by 5 matrix below, the minimal path sum from the top left to the bottom right by only moving right and down is indicated in red and is equal to 994.
    Find the minimal path sum from the top left to the bottom right in [data/0083_matrix.txt], a 31K text file containing a 80 by 80 matrix.
    """
    matrix = util.import_2d_array_data(filename)
    return util.modified_dijkstra(matrix,
                                  (0,0), # Start
                                  (len(matrix)-1, len(matrix[0])-1), # End
                                  )


def problem_84(iterations=1_000_000):
    board = [
        "GO", #00
        "A1",
        "CC1",
        "A2",
        "T1",
        "R1",
        "B1",
        "CH1",
        "B2",
        "B3",
        "JAIL", #10

        "C1",
        "U1",
        "C2",
        "C3",
        "R2",
        "D1",
        "CC2",
        "D2",
        "D3",
        "FP", #20

        "E1",
        "CH2",
        "E2",
        "E3",
        "R3",
        "F1",
        "F2",
        "U2",
        "F3",
        "G2J", #30

        "G1",
        "G2",
        "CC3",
        "G3",
        "R4",
        "CH3",
        "H1",
        "T2",
        "H2", #39
    ]
    class Monopoly:
        def __init__(self, dice_size=6, num_doubles_to_jail=3, num_community_chest=16, num_chance=16):
            self.CC = self.shuffle(["GO", "JAIL"]+[""]*(num_community_chest-2))
            self.CH = self.shuffle(["GO", "JAIL", "C1", "E3", "H2", "R1", "R", "R", "U", -3]+[""]*(num_chance-10))
            self.dice_size = dice_size
            self.current_square = 0
            self.visited_squares = dict.fromkeys(board, 0)
            self.num_doubles_to_jail = num_doubles_to_jail
            self.doubles_to_jail_streak = 0

        def shuffle(self, li):
            return random.sample(li, len(li))

        def turn(self, **kwargs):
            # Roll dice
            # Check for doubles, move to jail if 3x
            # Move player
            # Do square effect
            # Do card effect
            # Log results

            card = ""
            dice_result, is_double = self.roll_n(2)

            if is_double:
                self.doubles_to_jail_streak += 1
                if self.doubles_to_jail_streak == self.num_doubles_to_jail: # Go to jail, reset the counter
                    next_square = self.move_card("JAIL", self.current_square)
                    self.doubles_to_jail_streak = 0
                else: # No jail... yet
                    next_square = self.move_dice(sum(dice_result))
            else: # Not a double, reset the counter
                self.doubles_to_jail_streak = 0
                next_square = self.move_dice(sum(dice_result))

            # Do square effect
            if board[next_square].startswith("CC"):# Community Chest
                card, self.CC = self.draw_card(self.CC)
                if card != "":
                    next_square = self.move_card(card, next_square)
            elif board[next_square].startswith("CH"): # Chance
                card, self.CH = self.draw_card(self.CH)
                if isinstance(card, int): # Check if card is a number, since -3 is a special case
                    next_square = self.move_dice(card)
                elif card != "": # Check if card is anything else
                    next_square = self.move_card(card, next_square)
            if board[next_square] == "G2J": # Jail
                next_square = self.move_card("JAIL", self.current_square)

            self.current_square = next_square # Update the current square now that we're done moving
            self.visited_squares[board[self.current_square]] += 1 # Update visited squares

        def roll(self):
            # Roll dice using cryptographically secure random number generator
            return secrets.randbelow(self.dice_size) + 1

        def roll_n(self, n):
            # Returns a list of n rolls, and True if they are all the same
            rolls = [self.roll() for _ in range(n)]
            return rolls, len(set(rolls))==1

        def move_dice(self, dice_result):
            next_square = self.current_square + dice_result # Next square
            if next_square > len(board) - 1: # You can move forwards, so wrap
                next_square -= len(board)
            elif next_square < 0: # You can move backwards, so wrap
                next_square += len(board)
            return next_square

        def move_card(self, card, position):
        # Need a starting square for the move_card due to the R & U.
            while not board[position].startswith(card):
                position = (position + 1) % len(board)
            return position

        def draw_card(self, cards):
            li = cards.copy()
            drawn = li.pop(0)
            li.insert(len(li), drawn)
            return drawn, li

    game = Monopoly(dice_size=4)
    for _ in range(iterations):
        game.turn()
    di = util.top_x_from_dict(3, game.visited_squares)
    return "".join(f"{board.index(x):02d}" for x in di), di


def problem85():
    return None


def problem86():
    return None


def problem87(total=50_000_000):
    """Euler Problem 87: Prime square remainder theorem.

    The smallest number expressible as the sum of a prime square, prime cube, and prime fourth power is 28. In fact, there are exactly four distinct solutions for p < 100:
    28 = 2^2 + 2^3 + 2^4
    33 = 3^2 + 2^3 + 2^4
    49 = 5^2 + 2^3 + 2^4
    47 = 2^2 + 3^3 + 2^4
    How many numbers below fifty-million can be expressed as the sum of a prime square, prime cube, and prime fourth power?
    """
    instances = int(total**0.5)+1
    primes = util.prime_list(instances)
    squares = [x**2 for x in primes if x**2 < total]
    cubes = [x**3 for x in primes if x**3 < total]
    fourths = [x**4 for x in primes if x**4 < total]

    nums = set()

    for square in squares:
        for cube in cubes:
            if square + cube >= total:
                break
            for fourth in fourths:
                if square + cube + fourth >= total:
                    break
                nums.add(square + cube + fourth)
    return len(nums)


def problem88():
    return None


def prolem89():
    """Euler Problem 89: Roman numerals.

    For a number written in Roman numerals to be considered valid there are basic rules which must be followed.
    Even though the rules allow some numbers to be expressed in more than one way there is always a "best" way of writing a particular number.
    For example, it would appear that there are at least six ways of writing the number sixteen:
        IIIIIIIIIIIIIIII
        VIIIIIIIIIII
        VVIIIIII
        XIIIIII
        VVVI
        XVI

    However, according to the rules only XIIIIII and XVI are valid, and the last example is considered to be the most efficient, as it uses the least number of numerals.
    The 11K text file, roman.txt (right click and 'Save Link/Target As...'), contains one thousand numbers written in valid, but not necessarily minimal, Roman numerals; see About... Roman Numerals for the definitive rules for this problem.

    Find the number of characters saved by writing each of these in their minimal form.

    Note: You can assume that all the Roman numerals in the file contain no more than four consecutive identical units.
    """
    text_lines = util.import_text_file("data/0089_roman.txt")
    tracker = {"original": 0, "roman": 0}
    for line in text_lines:
        original = line.strip().upper() #Clean the line
        val = util.roman_numeral_to_int(original) #Convert to int
        roman = util.int_to_roman_numeral(val) #Convert to roman numerals
        tracker["original"] += len(original) #Add to tracker
        tracker["roman"] += len(roman) #Add to tracker
    return tracker["original"] - tracker["roman"] #Return the difference


def problem90():
    return None


def problem91():
    return None

def problem92(max_num=10000000, desired_final_total=89):
    """Euler Problem 92: Square digit chains.

    A number chain is created by continuously adding the square of the digits in a number to form a new number until it has been seen before.
    For example, 44 -> 32 -> 13 -> 10 -> 1 -> 1
    Will stop at 1 as it repeats itself.
    How many starting numbers below ten million will arrive at 89?
    """
    def check_final_total(x):
        curr = x
        while curr not in [1, 89]:
            curr = util.sum_digits_powers(curr,2)
        return curr
    di = {}
    for ea in range(1, max_num):
        val = util.sum_digits_powers(ea,2)
        if val in di:
            di[val] += 1
        else:
            di[val] = 1

    cum_tot = 0
    for key, value in di.items():
        if check_final_total(key) == desired_final_total:
            cum_tot+=value
    return cum_tot


def problem92_alt(max_num=10000000, desired_final_total=89):
    def get_totals_final_amount(max_num):
        li = [0]*81*len(util.convert_int_to_list(max_num))
        for ea in range(1, len(li)):
            if check_final_total(ea) == desired_final_total:
                li.append(ea)
        return set(li)
    def check_final_total(x):
        curr = x
        while curr not in [1, 89]:
            curr = util.sum_digits_powers(curr,2)
        return curr
    sums = get_totals_final_amount(max_num)
    ct = 0
    for ea in range(1, max_num):
        if util.sum_digits_powers(ea,2) in sums:
            ct+=1
    return ct


def problem93():
    return None


def problem94():
    return None


def problem95():
    return None


def problem96():
    return None


def problem97():
    """Euler Problem 97: Large non-Mersenne prime.

    The first known prime found to exceed one million digits was discovered in 1999, and is a Mersenne prime of the form 2^6972593 - 1; it contains exactly 2,098,960 digits. Subsequently other Mersenne primes, of the form 2^p - 1, have been found which contain more digits.
    However, in 2004 there was found a massive non-Mersenne prime which contains 2,357,207 digits: 28433 * 2^7830457 + 1.
    Find the last ten digits of this prime number.
    """
    x = (28433)*(2**7830457)+1
    return str(x % 10**10)

def problem98():
    return None


def problem99():
    return None

def problem100():
    return None
